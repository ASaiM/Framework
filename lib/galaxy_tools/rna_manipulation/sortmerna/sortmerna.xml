<tool id="sortmerna" name="Sort RNA">

	<description>with SortMeRNA</description>

    <macros>
    </macros>

	<requirements>
    </requirements>

    <stdio>
    </stdio>

    <version_command>
    </version_command>

  	<!--<command>-->
    <command interpreter="python">
        sortmerna_wrapper.py
            --src_dir $os.getcwd()
            --input_sequence_file $input_sequence_file

            #if str( $databases_type.databases_selector ) == 'history':
                #for $db in $databases_type.database_name
                    --db $db
                #end for
            #else:
                ## databases path is not directly accessible, must match by hand with LOC file contents
                #set $data_table = dict([(_[0], _[2]) for _ in $databases_type.input_databases.input.options.tool_data_table.data])
                #for $db in $databases_type.input_databases.value
                    #set $db_path=$os.getcwd() + '/'
                    #set $db_path += $data_table[$db]
                    --db $db_path
                #end for
            #end if

    
            #if $fastx.test:
                --aligned_sequence_file $aligned_sequence_file
                #if $fastx.rejected:
                    --rejected_sequence_file $rejected_sequence_file
                #end if
            #end if

            #if $sam.test:
                --sam_alignment_file $sam_alignment_file
                --add_sq_tag $sam.sq_tag:
            #end if

            #if $blast.test:
                --blast_output_file $blast_output_file
                --blast_output_format $blast.format
            #end if
            
            #if $log.test:
                --log_file $log_output_file
            #end if

            #if $report.type == 'best':
                #if $report.best.type == '0':
                    --best 0
                #else if $report.best.type == '1':
                    --best 1
                    --min_lis $report.best.min_lis
                #else
                    --best $report.best.value
                    --min_list $report.best.min_lis
                #end if
            #else
                #if $report.num_alignments.type == '0':
                    --num_alignments 0
                #else if $report.num_alignments.type == '1':
                    --num_alignments 1
                #else
                    --num_alignments $report.num_alignments.value
                #end if
            #end if

            --e_value $e_value
            --match $match
            --mismatch $mismatch
            --gap_open $gap_open
            --gap_ext $gap_ext
            --ambiguous_letter $ambiguous_letter
            --strand $strand

            --seed_length $seed_length
            --max_pos $max_pos

            --delete_tmp_dirpath True
    </command>

  	<inputs>
        <param name="input_sequence_file" type="data" format="fastq,fasta" label="Input sequence file" help=""/>

        <conditional name="databases_type">
            <param name="databases_selector" type="select" label="Databases to query" help="">
                <option value="cached" selected="true">Public ribosomal databases</option>
                <option value="history">Databases from your history</option>
            </param>
            <when value="cached">
                <param name="input_databases" label="rRNA databases" type="select" display="checkboxes" multiple="true">
                    <options from_data_table="sortmerna_rRNA_databases" />
                    <validator type="no_options" message="Select at least one database"/>
                </param>
            </when>
            <when value="history">
                <param name="database_name" type="data" format="fasta" multiple="true" label="rRNA databases"
                    help=""/>
            </when>
        </conditional>

        <conditional name="fastx">
            <param name="test" type='boolean' checked="true" truevalue='yes' falsevalue='no' label="Output into Fasta/FastQ file?" help="" />
            <when value="yes">
                <param name='rejected' type='boolean' checked="true" truevalue='yes' falsevalue='no' label="Conserve rejected reads?" help=""/>
            </when>
        </conditional>

        <conditional name="sam">
            <param name="test" type='boolean' checked="true" truevalue='yes' falsevalue='no' label="Output SAM alignments?" help="" />
            <when value="yes">
                <param name='sq_tag' type='boolean' checked="true" truevalue='yes' falsevalue='no' label="Add SQ tags to SAM file?" help=""/>
            </when>
        </conditional>

        <conditional name="blast">
            <param name='test' type='boolean' checked="true" truevalue='yes' falsevalue='no' label="Output BLAST alignments?" help=""/>
            <when value="yes">
                <param name="format" type="select" display="radio" label="Format for BLAST output" help="">
                    <option value="0">Pairwise</option>
                    <option value="1">Tabular (Blast -m 8 format)</option>
                    <option value="2">Tabular + column for CIGAR</option>
                    <option value="3" selected="true">Tabular + columns for CIGAR and query coverage</option>
                    <option value="4">Tabular + columns for CIGAR, query coverage and strand</option>
                </param>
            </when>
        </conditional>

        <conditional name="log">
            <param name='test' type='boolean' checked="true" truevalue='yes' falsevalue='no' label="Conserve overall statistic output into a log file?" help=""/>
        </conditional>

        <conditional name="report">
            <param name="type" type="select" display="radio" label="Parameters for filtering and read mapping" help="">
                <option value="best" selected="true">Report best alignments per read reaching E-value</option>
                <option value="num_alignments">Report first alignements per read reaching E-value</option>
            </param>
            <when value="best">
                <conditional name="best">
                    <param name="type" type="select" display="radio" label="Number of searched alignments" help="Only the best alignment is reported">
                        <option value="0">All high-candidate reference sequences are searched for alignments (very slow)</option>
                        <option value="1" selected="true">Only one high-candidate reference sequence is searched for alignments (fast). The high-candidate sequences are determined heuristically using a LIS of seed matches)</option>
                        <option value="other_value">A custom number of reference sequences are searched for alignments (speed decrease for high value)</option>
                    </param>
                    <when value="other_value">
                        <param name="value" type="integer" min="0" max="100" value="1" label="Number of alignments to be made" help="Only the best one is reported. The computation speed decrease with high value"/>
                        <param name="min_lis" type="integer" min="0" max="100" value="2" label="Number of longest LIS an alignement needs to be searched" help="The alignements having the first INT longest LIS. LIS stands for Longest Increasing Subsequence, it is computed using seeds' positions to expand hits into longer matches prior to Smith-Waterman alignment."/>
                    </when>
                    <when value="1">
                        <param name="min_lis" type="integer" min="0" max="100" value="2" label="Number of longest LIS an alignement needs to be searched" help="The alignements having the first INT longest LIS. LIS stands for Longest Increasing Subsequence, it is computed using seeds' positions to expand hits into longer matches prior to Smith-Waterman alignment."/>
                    </when>
                </conditional>
            </when>
            <when value="num_alignments">
                <conditional name="num_alignments">
                    <param name="type" type="select" display="radio" label="Number of output alignments" help="">
                        <option value="0">All alignments reaching the E-value threshold are reported (very slow, this option is not suggested for high similarity rRNA databases)</option>
                        <option value="1" selected="true">The first alignment passing E-value threshold are reported (very fast, best choice if only filtering is needed)</option>
                        <option value="other_value">A custom number of alignments are made and reported (speed decrease for high value)</option>
                    </param>
                    <when value="other_value">
                        <param name="value" type="integer" min="0" max="100" value="1" label="Number of alignments to be made and reported" help=""/>
                    </when>
                </conditional>
            </when>
        </conditional>

        <param name="e_value" type="float" min="0" max="10" value="1" label="E-value threshold" help=""/>
        <param name="match" type="integer" min="0" max="10" value="2" label="SW score for a match" help=""/>
        <param name="mismatch" type="integer" min="-10" max="0" value="-3" label="SW penalty for a mismatch" help=""/>
        <param name="gap_open" type="integer" min="0" max="10" value="5" label="SW penalty for introducing a gap" help=""/>
        <param name="gap_ext" type="integer" min="0" max="10" value="2" label="SW penalty for extending a gap" help=""/>
        <param name="ambiguous_letter" type="integer" min="-10" max="0" value="-3" label="SW penalty for ambiguous letters (N's)" help=""/>

        <param name="strand" type="select" display="radio" label="Search on" help="">
            <option value="both" selected="true">Both strands</option>
            <option value="forward" >Only forward strand</option>
            <option value="reverse" >Only reverse-complementary strand</option>
        </param>

        <param name="seed_length" type="integer" min="0" max="100" value="18" label="Seed length for database indexing" help=""/>
        <param name="max_pos" type="integer" min="0" max="100000" value="10000" label="Maximum number of positions to store for each k-mer for database indexing" help="With 0, all positions are stored"/>

  	</inputs>

  	<outputs>
        <data format="fastq,fasta" name="aligned_sequence_file" label="aligned_sequences_${input_sequence_file.name}">
            <filter>((fastx['test']))</filter>
        </data>

        <data format="fastq,fasta" name="rejected_sequence_file" label="rejected_sequences_${input_sequence_file.name}">
            <filter>((fastx['test'] and fastx['rejected']))</filter>
        </data>

        <data format="sam" name="sam_alignment_file" label="sam_alignment_${input_sequence_file.name}">
            <filter>((sam['test']]))</filter>
        </data>

        <data format="text" name="blast_output_file" label="rna_sorting_blast_output_${input_sequence_file.name}">
            <filter>((blast['test']))</filter>
        </data>

        <data format="text" name="log_output_file" label="rna_sorting_log_${input_sequence_file.name}">
            <filter>((log['test']))</filter>
        </data>


  	</outputs>

  	<tests>
  
  	</tests>

  	<help>
        **What it does**

        SortMeRNA is a tool for RNA filtering based on local sequence alignment
        against rRNA database

        **Input**

        

        **Outputs**

        


  	</help>

    <citations>
        <citation type="doi">10.1093/bioinformatics/bts611</citation>
    </citations>
</tool>

